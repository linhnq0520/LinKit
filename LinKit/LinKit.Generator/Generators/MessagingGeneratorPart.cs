using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;

namespace LinKit.Generator.Generators;

internal record MessageInfo(
    string MessageType,
    string TopicOrExchange,
    string RoutingKey,
    string? QueueName
);

internal static class MessagingGeneratorPart
{
    private const string MessageAttributeName = "LinKit.Core.Messaging.MessageAttribute";
    public static IncrementalValueProvider<IReadOnlyList<MessagingServiceInfo>> GetServices(
        IncrementalGeneratorInitializationContext context)
    {
        IncrementalValueProvider<ImmutableArray<MessageInfo?>> collectedMessages = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                MessageAttributeName,
                predicate: (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: (ctx, _) => GetMessageInfo(ctx))
            .Where(info => info is not null)!
            .Collect();

        return collectedMessages.Select((messages, _) =>
        {
            var services = new List<MessagingServiceInfo>();
            if (!messages.Any())
            {
                return (IReadOnlyList<MessagingServiceInfo>)services;
            }

            services.Add(new MessagingServiceInfo(
                "services.AddSingleton<LinKit.Core.Messaging.IMessagePublisher, LinKit.Generated.Messaging.GeneratedMessagePublisher>();"
            ));

            var messagesByQueue = messages
                .Where(m => !string.IsNullOrEmpty(m?.QueueName))
                .GroupBy(m => m?.QueueName);

            foreach (var queueGroup in messagesByQueue)
            {
                var queueName = queueGroup.Key!;
                var className = $"LinKit.Generated.Messaging.{new string(queueName.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray())}ConsumerService";

                services.Add(new MessagingServiceInfo(
                    $"services.AddSingleton<Microsoft.Extensions.Hosting.IHostedService, {className}>();"
                ));
            }

            return services;
        });
    }
    public static void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<MessageInfo?> messageDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                MessageAttributeName,
                predicate: (node, _) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                transform: (ctx, _) => GetMessageInfo(ctx))
            .Where(info => info is not null);

        context.RegisterSourceOutput(messageDeclarations.Collect(), (spc, messages) =>
        {
            var validMessages = messages.OfType<MessageInfo>().ToList();
            if (!validMessages.Any())
            {
                return;
            }

            var publisherSource = GeneratePublisher(validMessages);
            spc.AddSource("Messaging.Publisher.g.cs", SourceText.From(publisherSource, Encoding.UTF8));

            var consumerSource = GenerateConsumers(validMessages);
            spc.AddSource("Messaging.Consumers.g.cs", SourceText.From(consumerSource, Encoding.UTF8));
        });
    }

    private static MessageInfo? GetMessageInfo(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not INamedTypeSymbol messageSymbol)
        {
            return null;
        }

        var attributeData = context.Attributes[0];
        var topic = attributeData.ConstructorArguments[0].Value as string ?? string.Empty;
        var routingKey = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "RoutingKey").Value.Value as string
            ?? messageSymbol.Name;
        var queueName = attributeData.NamedArguments.FirstOrDefault(kvp => kvp.Key == "QueueName").Value.Value as string;

        return new MessageInfo(
            MessageType: messageSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            TopicOrExchange: topic,
            RoutingKey: routingKey,
            QueueName: queueName
        );
    }

    private static string GeneratePublisher(IReadOnlyList<MessageInfo> messages)
    {
        var sb = new StringBuilder();
        sb.AppendLine(@"// <auto-generated> by LinKit.Generator
#nullable enable
using LinKit.Core.Abstractions;
using LinKit.Core.Messaging;
using Microsoft.Extensions.DependencyInjection;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace LinKit.Generated.Messaging
{
    public sealed class GeneratedMessagePublisher : IMessagePublisher
    {
        private readonly IBrokerProducer _producer;
        private readonly IMessageMetadataProvider? _metadataProvider;

        public GeneratedMessagePublisher(IBrokerProducer producer, IServiceProvider serviceProvider)
        {
            _producer = producer;
            _metadataProvider = serviceProvider.GetService<IMessageMetadataProvider>();
        }

        public Task PublishAsync<TMessage>(TMessage message, CancellationToken ct = default)
        {
            if (message is null) return Task.CompletedTask;
            var headers = _metadataProvider?.GetHeaders(message);

            return (object)message switch
            {");

        foreach (var msg in messages)
        {
            sb.AppendLine($@"
                {msg.MessageType} m => _producer.ProduceAsync(""{msg.TopicOrExchange}"", ""{msg.RoutingKey}"", m, headers, ct),");
        }

        sb.AppendLine(@"
                _ => throw new System.InvalidOperationException($""Message type {typeof(TMessage).FullName} is not decorated with [Message] attribute."")
            };
        }
    }
}");
        return sb.ToString();
    }

    private static string GenerateConsumers(IReadOnlyList<MessageInfo> messages)
    {
        var sb = new StringBuilder();
        sb.AppendLine(@"// Auto-generated by LinKit.Generator
#nullable enable
using LinKit.Core.Abstractions;
using LinKit.Core.Cqrs;
using LinKit.Core.Messaging;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace LinKit.Generated.Messaging
{");

        var messagesByQueue = messages
            .Where(m => !string.IsNullOrEmpty(m.QueueName))
            .GroupBy(m => m.QueueName);

        foreach (var queueGroup in messagesByQueue)
        {
            var queueName = queueGroup.Key!;
            var className = $"{new string(queueName.Select(c => char.IsLetterOrDigit(c) ? c : '_').ToArray())}ConsumerService";

            sb.AppendLine($@"
    public sealed class {className} : BackgroundService
    {{
        private readonly IServiceProvider _serviceProvider;
        private readonly IBrokerConnection _connection;

        public {className}(IServiceProvider serviceProvider, IBrokerConnection connection)
        {{
            _serviceProvider = serviceProvider;
            _connection = connection;
        }}

        protected override Task ExecuteAsync(CancellationToken stoppingToken)
        {{
            return _connection.StartConsumingAsync(""{queueName}"", async (routingKey, body, headers) =>
            {{
                using var scope = _serviceProvider.CreateScope();
                var mediator = scope.ServiceProvider.GetRequiredService<IMediator>();

                try
                {{
                    switch(routingKey)
                    {{");

            foreach (var msg in queueGroup)
            {
                var varName = msg.MessageType.Split('.').Last().ToLowerInvariant();
                sb.AppendLine($@"
                        case ""{msg.RoutingKey}"":
                            var {varName} = JsonSerializer.Deserialize<{msg.MessageType}>(body);
                            if ({varName} is not null)
                            {{
                                // TODO: Add logic to pass headers into Cqrs Context if needed
                                await mediator.SendAsync({varName}, stoppingToken);
                            }}
                            break;");
            }

            sb.AppendLine(@"
                        default:
                            break;
                    }
                }
                catch
                {
                    throw; 
                }
            }, stoppingToken);
        }
    }");
        }

        sb.AppendLine(@"}");
        return sb.ToString();
    }
}